# OUTCARToGULP_ModeMap.py by J. M. Skelton


import csv;
import math;
import os;

from argparse import ArgumentParser;

# Import IO routines from OUTCARToGULP.py.

from OUTCARToGULP import _ReadOUTCARFile, _WriteGULPInputFile;


# Default base for the automatically-determined output file name.

_DefaultOutputFileNameBase = r"OUTCARToGULP_ModeMap.gulp";


# Main block.

if __name__ == "__main__":
    # Collect and parse command-line arguments.

    parser = ArgumentParser(description = "Extract fitting data for GULP from a VASP OUTCAR file");

    parser.set_defaults(
        OutputFile = None,

        OutputName = None,
        ModeMapCSV = None,

        AddCommands = False,

        GradientThreshold = 1.0e-5,
        StressThreshold = 1.0e-5
        );

    parser.add_argument(
        metavar = "<input_file>",
        nargs = '+', type = str, dest = 'InputFiles',
        help = "Input files to read"
        );

    parser.add_argument(
        "-o", "--output_file",
        metavar = "<output_file>",
        type = str, dest = 'OutputFile',
        help = "Output file (default: automatically determined)"
        );

    parser.add_argument(
        "-n", "--output_name",
        metavar = "<output_name>",
        type = str, dest = 'OutputName',
        help = "Optional identifier to be added to the header comment above each data block"
        );

    parser.add_argument(
        "--mode_map_csv",
        metavar = "<mode_map_csv>",
        type = str, dest = 'ModeMapCSV',
        help = "Optional \"ModeMap_PostProcess.csv\" file listing the normal-mode amplitudes and relative energies associated with each structure in a sequence generated by ModeMap.py"
        );

    parser.add_argument(
        "--add_commands",
        action = 'store_true', dest = 'AddCommands',
        help = "Add some basic commands to the GULP input file (default: no)"
        );

    parser.add_argument(
        "--gradient_threshold",
        metavar = "<threshold>",
        type = float, dest = 'GradientThreshold',
        help = "Threshold for the output of forces (gradients); sets of gradients where all components have absolute values less than this will not be output (default: 1.0e-5)"
        );

    parser.add_argument(
        "--stress_threshold",
        metavar = "<threshold>",
        type = float, dest = 'StressThreshold',
        help = "Threshold for the output of stress tensor components (strain derivatives); stress tensors where all components have absolute values less than this will not be output (default: 1.0e-5)"
        );

    args = parser.parse_args();

    # Perform some basic validation.

    if args.GradientThreshold != None and args.GradientThreshold < 0.0:
        raise Exception("Error: If supplied, the gradient component threshold must be >= 0.");

    if args.StressThreshold != None and args.StressThreshold < 0.0:
        raise Exception("Error: If supplied, the stress-tensor component threshold must be >= 0.");

    # Read input files.

    print("Reading input file(s)...");

    inputDataSets = [];

    for inputFile in args.InputFiles:
        print("  -> \"{0}\"".format(inputFile));

        formula, atomTypesList, atomicMassesList, structures, phononModes, elasticConstantMatrix = _ReadOUTCARFile(inputFile);

        # For this script, we expect input files to contain one structure, and not to contain data such as phonon frequencies/eigenvectors or an elastic-constant matrix.
        # If this is not the case, print a message to warn the user that some data will not be output.

        if len(structures) > 1 or (phononModes != None or elasticConstantMatrix != None):
            print("    -> WARNING: This script only outputs the gradients and/or stress tensor for the first structure in each input file; \"{0}\" contains additional structures/properties that will not be output.".format(inputFile));

        inputDataSets.append(
            (formula, atomTypesList, structures[0])
            );

    print("");

    # If a "ModeMap_PostProcess.csv" file was passed via the --mode_map_csv command-line argument, read in the normal-mode amplitudes and relative energies of each input structure.

    modeMapAmplitudesEnergies = None;

    if args.ModeMapCSV != None:
        modeMapAmplitudesEnergies = [];

        print("Reading \"{0}\"...".format(args.ModeMapCSV));

        with open(args.ModeMapCSV, 'r') as inputReader:
            inputReaderCSV = csv.reader(inputReader);

            # Skip three rows.

            for i in range(0, 3):
                next(inputReaderCSV);

            # Each row contains Q, U(Q), dU(Q) columns - the first and last will be used to generate labels.

            for i, row in enumerate(inputReaderCSV):
                q, uQ, dUQ = [float(item) for item in row];

                modeMapAmplitudesEnergies.append(
                    (q, dUQ)
                    );

        # Sanity check.

        if len(modeMapAmplitudesEnergies) != len(inputDataSets):
            raise Exception("Error: If a \"ModeMap_PostProcess.csv\" file is supplied via the --mode_map_csv argument, it must contain one entry for each input file.");

        print("");

    # Generate descriptive header comments and names for each data set.

    dataSetLabels = [];

    for i, (formula, _, _) in enumerate(inputDataSets):
        # Generate a name to insert into the header comment.

        outputName = None;

        # If an identifier was supplied via the --output_name command-line argument, use this as a base; if not, use the structure number.

        if args.OutputName != None:
            # If we have mode amplitudes, we have information to assign each structure a unique header comment; if not, append the file number to the identifier instead.

            if modeMapAmplitudesEnergies != None:
                outputName = args.OutputName;
            else:
                outputName = "{0}, Input File {1}".format(args.OutputName, i + 1);
        else:
            outputName = "Input File {0} ({1})".format(i + 1, args.InputFiles[i]);

        # If the --mode_map_csv argument was supplied via the command line, we assume we are processing a mode map calculation.

        if modeMapAmplitudesEnergies != None:
            outputName = "mode map {0}".format(outputName);

        # Build the output name into the header comment.

        headerComment = "Data for {0}".format(outputName);

        # If we are processing a mode map calculation, append the mode amplitude and relative energy to the header comment.

        if modeMapAmplitudesEnergies != None:
            q, dUQ = modeMapAmplitudesEnergies[i];
            headerComment = "{0} w/ Q = {1:.2f} amu^1/2 A, dU(Q) = {2:.0f} meV".format(headerComment, q, dUQ);

        # Generate a name to add to the GULP data block.

        name = formula;

        # If we are processing a mode map calculation, use the mode amplitude in the name.

        if modeMapAmplitudesEnergies != None:
            q, _ = modeMapAmplitudesEnergies[i];
            name = "{0} (Input File {1} w/ Q = {2:.2f})".format(name, i + 1, q);
        else:
            name = "{0} (Input File {1})".format(name, i + 1);

        dataSetLabels.append(
            (headerComment, name)
            );

    # Build a list of data sets to output.

    outputDataSets = [];

    # We only want to output data blocks for structures where the forces (gradients) and/or stress tensor elements are above the set thresholds.

    for i, (_, atomTypesList, structure) in enumerate(inputDataSets):
        latticeVectors, atomPositions, totalEnergy, stressTensor, forceSet = structure;

        # Decide whether to output the gradients.

        outputGradients = False;

        # If no threshold is set, output by default.

        if args.GradientThreshold == None:
            outputGradients = True;
        else:
            # If a threshold has been set, check the components of the forces against the threshold.

            for fx, fy, fz in forceSet:
                if math.fabs(fx) >= args.GradientThreshold or math.fabs(fy) >= args.GradientThreshold or math.fabs(fz) >= args.GradientThreshold:
                    outputGradients = True;
                    break;

        # Decide whether to output the stress tensor.

        outputStressTensor = False;

        if stressTensor != None:
            # Again, if no threshold is set, output by default (if available).

            if args.StressThreshold == None:
                outputStressTensor = True;
            else:
                # If a threshold has been set, the stress tensor components are output when any are above the threshold.

                for element in stressTensor:
                    outputStressTensor = outputStressTensor or math.fabs(element) / 10.0 >= args.StressThreshold;

        # Fetch the header comment and output name.

        headerComment, name = dataSetLabels[i];

        # Add the structure to the output data sets if required.

        if outputGradients or outputStressTensor:
            outputDataSet = {
                'HeaderComment' : headerComment,
                'Name' : name,

                'LatticeVectors' : latticeVectors,
                'AtomTypesList' : atomTypesList,
                'AtomPositions' : atomPositions,

                'TotalEnergy' : totalEnergy
                };

            if outputStressTensor:
                outputDataSet['StressTensor'] = stressTensor;

            if outputGradients:
                outputDataSet['ForceSet'] = forceSet;

            outputDataSets.append(outputDataSet);
        else:
            # If the gradients and diagonal stress-tensor elements are below the threshold, output a comment to note why the data set was excluded.

            outputDataSets.append(
                { 'HeaderComment' : "INFO: The gradient and/or stress-tensor components for \"{0}\" ({1}) are below the set thresholds (gradients: {2:.2e}, stress: {3:.2e}) -> data set not output.".format(name, args.InputFiles[i], args.GradientThreshold, args.StressThreshold) }
                );

    # Work out a name for the output file.

    outputFile = args.OutputFile;

    if outputFile == None:
        outputFile = _DefaultOutputFileNameBase;

        # Avoid overwriting the default output file if already present.

        root, ext = os.path.splitext(_DefaultOutputFileNameBase);

        if os.path.isfile(outputFile):
            fileNumber = 2;

            while True:
                outputFile = "{0}-{1}.{2}".format(root, fileNumber, ext);

                if not os.path.isfile(outputFile):
                    break;

                fileNumber = fileNumber + 1;

    # Write out the data sets.

    print( "Writing data to \"{0}\"...".format(outputFile))

    _WriteGULPInputFile(outputDataSets, outputFile, addCommands = args.AddCommands);

    print("");

    # Print a "finished" message.

    print("Done!");
